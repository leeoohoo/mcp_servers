Python 中有几个库可以实现精准的文本修改，特别是基于行号的操作。以下是一些推荐的方案：

## 1. **内置方法 - 最直接的方案**

```python
def modify_text_by_lines(file_path, start_line, end_line, new_content):
    """
    根据起始行和结束行精准修改文本
    
    Args:
        file_path: 文件路径
        start_line: 起始行号 (1-based)
        end_line: 结束行号 (1-based)
        new_content: 新内容 (字符串或字符串列表)
    """
    with open(file_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    # 转换为 0-based 索引
    start_idx = start_line - 1
    end_idx = end_line
    
    # 确保 new_content 是列表格式
    if isinstance(new_content, str):
        new_lines = [new_content + '\n'] if not new_content.endswith('\n') else [new_content]
    else:
        new_lines = [line + '\n' if not line.endswith('\n') else line for line in new_content]
    
    # 替换指定行
    modified_lines = lines[:start_idx] + new_lines + lines[end_idx:]
    
    with open(file_path, 'w', encoding='utf-8') as f:
        f.writelines(modified_lines)

# 使用示例
modify_text_by_lines('test.txt', 5, 7, ['新的第5行', '新的第6行', '新的第7行'])
```

## 2. **fileinput 模块 - 标准库方案**

```python
import fileinput
import sys

def modify_lines_with_fileinput(file_path, line_modifications):
    """
    使用 fileinput 模块修改特定行
    
    Args:
        file_path: 文件路径
        line_modifications: 字典，{行号: 新内容}
    """
    with fileinput.FileInput(file_path, inplace=True) as file:
        for line_num, line in enumerate(file, 1):
            if line_num in line_modifications:
                print(line_modifications[line_num], end='')
            else:
                print(line, end='')

# 使用示例
modifications = {
    3: "这是修改后的第3行\n",
    5: "这是修改后的第5行\n",
    8: "这是修改后的第8行\n"
}
modify_lines_with_fileinput('test.txt', modifications)
```

## 3. **更高级的文本编辑类**

```python
class TextEditor:
    def __init__(self, file_path):
        self.file_path = file_path
        with open(file_path, 'r', encoding='utf-8') as f:
            self.lines = f.readlines()
    
    def replace_lines(self, start_line, end_line, new_content):
        """替换指定范围的行"""
        start_idx = start_line - 1
        end_idx = end_line
        
        if isinstance(new_content, str):
            new_lines = [new_content + '\n'] if not new_content.endswith('\n') else [new_content]
        else:
            new_lines = [line + '\n' if not line.endswith('\n') else line for line in new_content]
        
        self.lines = self.lines[:start_idx] + new_lines + self.lines[end_idx:]
        return self
    
    def insert_lines(self, line_num, content):
        """在指定行号后插入内容"""
        if isinstance(content, str):
            content = [content]
        
        insert_lines = [line + '\n' if not line.endswith('\n') else line for line in content]
        self.lines = self.lines[:line_num] + insert_lines + self.lines[line_num:]
        return self
    
    def delete_lines(self, start_line, end_line):
        """删除指定范围的行"""
        start_idx = start_line - 1
        end_idx = end_line
        self.lines = self.lines[:start_idx] + self.lines[end_idx:]
        return self
    
    def get_lines(self, start_line=None, end_line=None):
        """获取指定范围的行"""
        if start_line is None and end_line is None:
            return self.lines
        
        start_idx = (start_line - 1) if start_line else 0
        end_idx = end_line if end_line else len(self.lines)
        return self.lines[start_idx:end_idx]
    
    def save(self, file_path=None):
        """保存文件"""
        path = file_path or self.file_path
        with open(path, 'w', encoding='utf-8') as f:
            f.writelines(self.lines)
        return self

# 使用示例
editor = TextEditor('test.txt')
editor.replace_lines(3, 5, ['新的第3行', '新的第4行', '新的第5行']) \
      .insert_lines(10, '插入的新行') \
      .delete_lines(15, 17) \
      .save()
```

## 4. **使用第三方库 - `rope` (代码重构库)**

```python
# pip install rope
from rope.base.project import Project
from rope.base.resources import File

def modify_with_rope(file_path, start_line, end_line, new_content):
    """使用 rope 库进行精准修改"""
    project = Project('.')
    file_resource = project.get_resource(file_path)
    
    # 读取文件内容
    content = file_resource.read()
    lines = content.splitlines(True)
    
    # 计算字符偏移量
    start_offset = sum(len(line) for line in lines[:start_line-1])
    end_offset = sum(len(line) for line in lines[:end_line])
    
    # 执行替换
    if isinstance(new_content, list):
        new_text = ''.join(new_content)
    else:
        new_text = new_content
    
    new_content_full = content[:start_offset] + new_text + content[end_offset:]
    file_resource.write(new_content_full)
    
    project.close()
```

## 5. **实用工具函数集合**

```python
import os
import shutil
from typing import Union, List, Dict

class PreciseTextModifier:
    def __init__(self, file_path: str, backup: bool = True):
        self.file_path = file_path
        if backup:
            shutil.copy2(file_path, f"{file_path}.backup")
        
        with open(file_path, 'r', encoding='utf-8') as f:
            self.lines = f.readlines()
    
    def modify_line(self, line_num: int, new_content: str) -> 'PreciseTextModifier':
        """修改单行"""
        if 1 <= line_num <= len(self.lines):
            self.lines[line_num - 1] = new_content + '\n' if not new_content.endswith('\n') else new_content
        return self
    
    def modify_range(self, start_line: int, end_line: int, new_content: Union[str, List[str]]) -> 'PreciseTextModifier':
        """修改行范围"""
        if isinstance(new_content, str):
            new_lines = [new_content + '\n'] if not new_content.endswith('\n') else [new_content]
        else:
            new_lines = [line + '\n' if not line.endswith('\n') else line for line in new_content]
        
        start_idx = start_line - 1
        end_idx = end_line
        self.lines = self.lines[:start_idx] + new_lines + self.lines[end_idx:]
        return self
    
    def batch_modify(self, modifications: Dict[int, str]) -> 'PreciseTextModifier':
        """批量修改多行"""
        for line_num in sorted(modifications.keys(), reverse=True):  # 从后往前修改避免行号变化
            self.modify_line(line_num, modifications[line_num])
        return self
    
    def save(self, output_path: str = None) -> None:
        """保存文件"""
        path = output_path or self.file_path
        with open(path, 'w', encoding='utf-8') as f:
            f.writelines(self.lines)

# 使用示例
modifier = PreciseTextModifier('test.txt')
modifier.modify_line(3, "修改第3行") \
        .modify_range(5, 7, ["新第5行", "新第6行", "新第7行"]) \
        .batch_modify({10: "修改第10行", 15: "修改第15行"}) \
        .save()
```

## 推荐方案

对于大多数场景，我推荐使用 **方案3 (TextEditor类)** 或 **方案5 (PreciseTextModifier类)**，因为它们：

1. **功能完整**：支持替换、插入、删除等多种操作
2. **链式调用**：可以连续进行多个操作
3. **错误处理**：包含基本的边界检查
4. **备份功能**：自动创建备份文件
5. **易于扩展**：可以根据需要添加更多功能

这些方案都能实现基于行号的精准文本修改，你可以根据具体需求选择合适的方案。