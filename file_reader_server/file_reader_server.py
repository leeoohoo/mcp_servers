#!/usr/bin/env python3
"""
File Reader MCP Server (Ê≥®Ëß£ÁâàÊú¨)
Âü∫‰∫é EnhancedMCPServer ÂíåË£ÖÈ•∞Âô®Á≥ªÁªüÁöÑÊñá‰ª∂ËØªÂèñÊúçÂä°Âô®

‰∏ªË¶ÅÂäüËÉΩ:
1. read_file_lines - ËØªÂèñÊñá‰ª∂ÊåáÂÆöË°åËåÉÂõ¥ÔºàÊµÅÂºèËæìÂá∫Ôºâ
2. search_files_by_content - ÊêúÁ¥¢Êñá‰ª∂ÂÜÖÂÆπÔºàÊµÅÂºèËæìÂá∫Ôºâ  
3. get_files_content - ÊâπÈáèËØªÂèñÊñá‰ª∂ÂÜÖÂÆπÔºàÊµÅÂºèËæìÂá∫Ôºâ
4. get_project_structure - Ëé∑ÂèñÈ°πÁõÆÁªìÊûÑÔºàÊµÅÂºèËæìÂá∫Ôºâ
"""

import asyncio
import json
import logging
import os
import re
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional, AsyncGenerator
from typing_extensions import Annotated

# WhooshÁõ∏ÂÖ≥ÂØºÂÖ•
from whoosh.index import create_in, open_dir, exists_in
from whoosh.fields import Schema, TEXT, ID, DATETIME
from whoosh.qparser import QueryParser
from whoosh.highlight import Highlighter, ContextFragmenter

# ÂØºÂÖ•Êñá‰ª∂ËØªÂèñÊúçÂä°
from file_reader_service import FileReaderService

# ÂØºÂÖ•Êñ∞ÁöÑÊ°ÜÊû∂
from mcp_framework import (

    MCPHTTPServer,
    ConfigManager,
    setup_logging,
    check_dependencies
)
from mcp_framework.core import EnhancedMCPServer

# ÂØºÂÖ•Ë£ÖÈ•∞Âô®
from mcp_framework.core.decorators import (
    Required as R,
    Optional as O,
    IntRange,
    ServerParam,
    StringParam,
    BooleanParam,
    PathParam
)

# ÈÖçÁΩÆÊó•Âøó
logger = logging.getLogger("file_reader_server")


# FileReaderService Á±ªÂ∑≤ÁßªÂä®Âà∞Áã¨Á´ãÁöÑ file_reader_service.py Êñá‰ª∂‰∏≠


class FileReaderMCPServer(EnhancedMCPServer):
    """Âü∫‰∫éÊ≥®Ëß£Ë£ÖÈ•∞Âô®ÁöÑÊñá‰ª∂ËØªÂèñMCPÊúçÂä°Âô®"""

    def __init__(self):
        super().__init__(
            name="file-reader-server",
            version="1.0.0",
            description="Êñá‰ª∂ËØªÂèñMCPÊúçÂä°Âô®ÔºåÂü∫‰∫éÊ≥®Ëß£Ë£ÖÈ•∞Âô®Á≥ªÁªüÊèê‰æõÊµÅÂºèÊñá‰ª∂Êìç‰ΩúÂäüËÉΩ"
        )
        # Âú®ÊûÑÈÄ†ÂáΩÊï∞‰∏≠Â∞±ÂàùÂßãÂåñÊúçÂä°Ôºå‰ΩøÁî®ÈªòËÆ§ÂÄº
        self.file_reader_service = FileReaderService()
        logger.info("FileReaderMCPServer initialized")

    @property
    def setup_tools(self):
        """ËÆæÁΩÆÂ∑•ÂÖ∑Ë£ÖÈ•∞Âô®"""

        @self.streaming_tool(description="üìñ **File Line Range Reader** - Reads specific line ranges from a file and returns content with line numbers.\n" +
                         "‚ú® Features: Precise line-based reading with 1-based indexing, Support for both relative and absolute file paths\n" +
                         "üéØ Use Cases: Code review and analysis, Understanding specific code sections, Debugging and error investigation\n" +
                         "üìã **Required Parameters**: file_path, start_line, end_line (ALL parameters are mandatory)\n" +
                         "üìã **Usage Example**: {\"file_path\": \"src/main/kotlin/User.kt\", \"start_line\": 10, \"end_line\": 20}\n" +
                         "‚ö†Ô∏è **CRITICAL Output Format**: Returns compressed format like '10:class User {\\n12:private val name\\n14:fun getName()' - gaps in line numbers (e.g., missing 11, 13) indicate empty/blank lines were automatically skipped for efficiency\n" +
                         "üí° Perfect for examining specific code sections without reading entire files. Line number gaps are NORMAL and expected.")
        async def read_file_lines(
                file_path: Annotated[str, R("Path to the file to read (supports both relative and absolute paths)")],
                start_line: Annotated[int, IntRange("Starting line number (1-based indexing)", min_val=1)],
                end_line: Annotated[int, IntRange("Ending line number (1-based indexing, inclusive)", min_val=1)]
        ) -> AsyncGenerator[str, None]:
            """Reads specific line ranges from a file and returns content with line numbers"""
            project_root = self.get_config_value('project_root')
            async for chunk in self.file_reader_service.read_file_lines_stream(file_path, start_line, end_line, Path(project_root)):
                yield self._normalize_stream_chunk(chunk)

        @self.streaming_tool(description="üß† **Hybrid Intelligent Search** - Combines smart semantic search with global text search for comprehensive results.\n" +
                         "‚ú® First attempts intelligent search (Class#method format, code structure understanding), then falls back to global text search if no results found.\n" +
                         "üéØ Use cases: API exploration, code understanding, architecture analysis, configuration lookup, constant search.\n" +
                         "üí° Examples: 'UserService#login', 'BaseConfigPOJO', 'DATABASE_URL', 'TODO'\n" +
                         "üìã **Parameter**: query - The search text to find in files\n" +
                         "‚ö†Ô∏è **Output Format**: Shows line numbers like '1:code 3:code' - missing line 2 means it was empty/blank.")
        async def search_files_by_content(
                query: Annotated[str, R("The search text to find in files: supports class names (e.g., UserService), method references (e.g., Class#method), file names, functional descriptions, or exact text matches")]
        ) -> AsyncGenerator[str, None]:
            """Combines smart semantic search with global text search for comprehensive results"""
            project_root = self.get_config_value('project_root')
            async for chunk in self.file_reader_service.search_files_by_content_stream(
                    query, 20, False, 20, None, Path(project_root)
            ):
                yield self._normalize_stream_chunk(chunk)

        # get_files_content Â∑•ÂÖ∑Â∑≤ÁßªÈô§

        @self.streaming_tool(description="üèóÔ∏è **Project Structure with Line Count** - Retrieves a hierarchical structure of the project with file line counts.\n" +
                         "‚ú® Provides complete project organization with detailed file information including line counts.\n" +
                         "üéØ Use cases: Understanding project architecture, analyzing code distribution, getting overview of file sizes.\n" +
                         "üí° Examples: Getting project structure with line counts for each file to understand codebase scale")
        async def get_project_structure(
                max_depth: Annotated[int, O("Maximum traversal depth", default=10, minimum=1)] = 10,
                include_hidden: Annotated[bool, O("Whether to include hidden files", default=False)] = False
        ) -> AsyncGenerator[str, None]:
            """Retrieves a hierarchical structure of the project with file line counts"""
            project_root = self.get_config_value('project_root')
            async for chunk in self.file_reader_service.get_project_structure_stream(max_depth, include_hidden, Path(project_root)):
                yield self._normalize_stream_chunk(chunk)



        @self.resource(uri="config://file-reader", name="File Reader Configuration", description="Current file reader configuration information")
        async def file_reader_config_resource(uri: str) -> Dict[str, Any]:
            """Get file reader configuration information"""
            config_info = {
                "project_root": str(self.file_reader_service.get_project_root()),
                "supported_extensions": list(self.file_reader_service.text_extensions),
                "ignored_directories": list(self.file_reader_service.ignore_dirs),
                "server_config": getattr(self, 'server_config', {})
            }
            return {
                "contents": [
                    {
                        "uri": uri,
                        "mimeType": "application/json",
                        "text": json.dumps(config_info, indent=2, ensure_ascii=False)
                    }
                ]
            }

        @self.resource(uri="stats://project", name="Project Statistics", description="Project file and code line count statistics")
        async def project_stats_resource(uri: str) -> Dict[str, Any]:
            """Get project statistics information"""
            # ËÆ°ÁÆóÈ°πÁõÆÁªüËÆ°‰ø°ÊÅØ
            total_files = 0
            total_lines = 0
            file_types = {}

            try:
                project_root = self.file_reader_service.get_project_root()
                for file_path in project_root.rglob('*'):
                    if not file_path.is_file():
                        continue

                    relative_path = file_path.relative_to(project_root)
                    if self.file_reader_service._should_ignore_path(relative_path):
                        continue

                    total_files += 1
                    ext = file_path.suffix.lower()
                    file_types[ext] = file_types.get(ext, 0) + 1

                    if ext in self.file_reader_service.text_extensions:
                        try:
                            with open(file_path, 'r', encoding='utf-8') as f:
                                lines = sum(1 for _ in f)
                                total_lines += lines
                        except (UnicodeDecodeError, PermissionError):
                            pass

                stats_info = {
                    "project_root": str(project_root),
                    "total_files": total_files,
                    "total_lines": total_lines,
                    "file_types": file_types,
                    "text_file_extensions": len(self.file_reader_service.text_extensions)
                }

            except Exception as e:
                stats_info = {"error": f"Failed to calculate stats: {str(e)}"}

            return {
                "contents": [
                    {
                        "uri": uri,
                        "mimeType": "application/json",
                        "text": json.dumps(stats_info, indent=2, ensure_ascii=False)
                    }
                ]
            }

        return True

    @property
    def setup_server_params(self):
        """ËÆæÁΩÆÊúçÂä°Âô®ÂèÇÊï∞Ë£ÖÈ•∞Âô®"""

        @self.decorators.server_param("project_root")
        async def project_root_param(
                param: Annotated[str, PathParam(
                    display_name="Project Root Directory",
                    description="Root directory path for server operations, leave empty to use current directory",
                    required=False,
                    placeholder="/path/to/project"
                )]
        ):
            """Project root directory parameter"""
            pass

        @self.decorators.server_param("max_file_size")
        async def max_file_size_param(
                param: Annotated[int, ServerParam(
                    display_name="Maximum File Size (MB)",
                    description="Maximum file size allowed for reading, in MB",
                    param_type="integer",
                    default_value=10,
                    required=False
                )]
        ):
            """Maximum file size parameter"""
            pass

        @self.decorators.server_param("enable_hidden_files")
        async def enable_hidden_files_param(
                param: Annotated[bool, BooleanParam(
                    display_name="Enable Hidden Files",
                    description="Whether to allow access to hidden files starting with dot (.)",
                    default_value=False,
                    required=False
                )]
        ):
            """Enable hidden files parameter"""
            pass

        @self.decorators.server_param("search_limit")
        async def search_limit_param(
                param: Annotated[int, ServerParam(
                    display_name="Search Result Limit",
                    description="Maximum number of results returned by search operations",
                    param_type="integer",
                    default_value=50,
                    required=False
                )]
        ):
            """Search result limit parameter"""
            pass

        return True

    async def initialize(self) -> None:
        """ÂàùÂßãÂåñÊúçÂä°Âô®ÔºàÂÆûÁé∞Âü∫Á±ªÊäΩË±°ÊñπÊ≥ïÔºâ"""
        # ÂàùÂßãÂåñÊñá‰ª∂ËØªÂèñÊúçÂä°Ôºå‰º†ÈÄíself‰Ωú‰∏∫serverÂèÇÊï∞
        # ÊúçÂä°Â∞ÜÈÄöËøáserverËé∑ÂèñÈÖçÁΩÆÂÄº
        self.file_reader_service = FileReaderService(server=self)
        logger.info("Initialized file reader service with server reference")

    async def on_config_updated(self, config_key: str, new_value: Any) -> None:
        """ÈÖçÁΩÆÊõ¥Êñ∞ÂõûË∞ÉÊñπÊ≥ï"""
        if config_key == "project_root":
            try:
                # ÈÖçÁΩÆÂ∑≤ÁªèÂú®Âü∫Á±ª‰∏≠Êõ¥Êñ∞ÔºåÂè™ÈúÄË¶ÅÈÄöÁü•ÊúçÂä°Êõ¥Êñ∞Á¥¢ÂºïÁõÆÂΩïÂíåÁõëÊéßÂô®
                if self.file_reader_service:
                    project_root = str(new_value).strip() if new_value else ""
                    result = self.file_reader_service.update_project_root(project_root)
                    
                    if "success" in result:
                        logger.info(f"Config updated successfully: {result['message']}")
                    else:
                        logger.error(f"Failed to update project root: {result.get('error', 'Unknown error')}")
                else:
                    # Â¶ÇÊûúÊúçÂä°Êú™ÂàùÂßãÂåñÔºåÂàõÂª∫Êñ∞ÊúçÂä°
                    self.file_reader_service = FileReaderService()
                    # Â¶ÇÊûúÊúâÈÖçÁΩÆÂÄºÔºåÊõ¥Êñ∞È°πÁõÆÊ†πÁõÆÂΩï
                    if new_value and str(new_value).strip():
                        self.file_reader_service.update_project_root(str(new_value).strip())
                        logger.info(f"Config updated: Created new service with project root: {new_value}")
                    else:
                        logger.info("Config updated: Created new service with current directory as project root")
                    
            except Exception as e:
                logger.error(f"Failed to update config for {config_key}: {e}")
        else:
            logger.info(f"Config updated: {config_key} = {new_value}")

    async def cleanup(self) -> None:
        """ÊúçÂä°ÂÅúÊ≠¢Êó∂ÁöÑÊ∏ÖÁêÜÊñπÊ≥ï"""
        try:
            if self.file_reader_service:
                # ÂÅúÊ≠¢Êñá‰ª∂ÁõëÊéß
                result = self.file_reader_service.stop_monitoring()
                if "success" in result:
                    logger.info(f"Êñá‰ª∂ÁõëÊéßÂ∑≤ÂÅúÊ≠¢: {result['message']}")
                elif "error" in result:
                    logger.warning(f"ÂÅúÊ≠¢Êñá‰ª∂ÁõëÊéßÊó∂Âá∫Áé∞ÈóÆÈ¢ò: {result['error']}")
                else:
                    logger.info(f"Êñá‰ª∂ÁõëÊéßÁä∂ÊÄÅ: {result['message']}")
            
            # Ë∞ÉÁî®Âü∫Á±ªÁöÑÊ∏ÖÁêÜÊñπÊ≥ïÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
            if hasattr(super(), 'cleanup'):
                await super().cleanup()
                
            logger.info("FileReaderMCPServer cleanup completed")
        except Exception as e:
            logger.error(f"Ê∏ÖÁêÜËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ: {e}")

    async def shutdown(self) -> None:
        """ÊúçÂä°ÂÖ≥Èó≠Êó∂ÁöÑÂ§ÑÁêÜÊñπÊ≥ï"""
        await self.cleanup()


def main():
    """‰∏ªÂáΩÊï∞"""
    try:
        # ÂØºÂÖ• MCP Ê°ÜÊû∂ÂêØÂä®Âô®
        from mcp_framework import run_server_main
        
        # ÂàõÂª∫ÊúçÂä°Âô®ÂÆû‰æã
        server = FileReaderMCPServer()
        
        # ‰ΩøÁî® MCP Ê°ÜÊû∂ÂêØÂä®Âô®ÂêØÂä®ÊúçÂä°Âô®
        run_server_main(
            server_instance=server,
            server_name="File Reader MCP Server",
            default_port=8082,
            default_host="localhost",
            required_dependencies=[]
        )
    except Exception as e:
        logger.error(f"ÂêØÂä®ÊúçÂä°Âô®Â§±Ë¥•: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
